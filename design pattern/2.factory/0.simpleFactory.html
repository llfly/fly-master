<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
</html>
<script type="text/javascript">
	var LoginAlert = function(text){
		this.content = text;
	}
	LoginAlert.prototype.show = function(){
		//show alert
	}
	var userNameAlert = new LoginAlert('用户名不得少于6个字符');
	userNameAlert.show();

	var LoginConfirm = function(text){
		this.content = text;
	}
	LoginConfirm.prototype.show = function(){
		//show confrim
	}
	var LoginConfirm = new LoginConfirm();
	LoginConfirm.show();

	var PopFactory = function(type){
		switch(type){
			case 'alert' :
			return new LoginAlert();
			case 'confrim':
			return new LoginConfirm();
		}
	}

//----------------------------------------------------------------------------------------------
	var Basketball = function(){
		this.intro = '篮球';
	}
	Basketball.prototype = {
		getMember:function(){
			console.log('每个队伍需要5名队员');
		},
		getBallSize:function(){
			console.log('18');
		}
	}

	var Football = function(){
		this.intro = '足球';
	}
	Football.prototype = {
		getMember:function(){
			console.log('每个队伍需要11名队员');
		},
		getBallSize:function(){
			console.log('18')
		}
	}
	var Tennis = function(){
		this.intro = '网球';
	}
	Tennis.prototype = {
		getMember:function(){
			console.log('每个队伍需要1名队员');
		},
		getBallSize:function(){
			console.log('1');
		}
	}

	var SprotsFactory = function(name){
		switch(name){
			case 'baskeball':
			return new Basketball();
			case 'football':
			return new Football();
			case 'tennis':
			return new Tennis();
		}
	}

	var football = SprotsFactory('baskeball');
	console.log(football);
	console.log(football.intro);
	football.getMember();


//----------------------------------------------------------------------------------------------
	function createBook(name,time,type){
		//创建一个对象，并对对象拓展属性和方法
		var o = new Object();
		o.name = name;
		o.time = time;
		o.type = type;
		o.getName = function(){
			console.log(this.name);
		};
		return o;
	}
	var book1 = createBook('js book',2014,'js');
	var book2 = createBook('css book',2016,'css');

	book1.getName();
	book2.getName();


//----------------------------------------------------------------------------------------------
	function createPop(type,text){
		var o = new Object();
		o.show = function(){

		};
		if(type == 'alert'){

		};
		if(type == 'confirm'){

		}
		return o;
	}
	var type = createPop('alert','用户名最少6位数');

	//第一种通过类实例化对象创建
	//第二种通过创建一个新对象然后包装增强其属性和功能实现
	//它们之间的差异也造成了前面通过类创建的对象，如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。
	//后面寄生方式创建的对象都是一个新的个体，所以方法不能共用。

//----------------------------------------------------------------------------------------------

	var BicyleShop = function(){};
	BicyleShop.prototype = {
		sellBicyle:function(model){
			var bicycle;
			switch(model){
				case 'The Speedster':
					bicycle = new Speedster();
					break;
				case 'The Lowrider':
					bicycle = new Lowrider();
				case 'The Comfort Cruiser':
				default:
					bicycle = new ComfortCruiser();
			}
			Interface.ensureImplements(bicycle,Bicyle);
			bicycle.assemble();
			bicycle.wash();

			return bicycle;
		}
	}
	//接口在工厂模式中起着很重要的作用，如果不对对象进行某种类型检查以确保其实现了必须的方法，工厂模式带来的好处就所剩无几了。
	
	var Bicyle = new Interface('Bicyle',['assemble','wash','ride','repair']);

	var Speedster = function(){};
	Speedster.prototype = {
		assemble:function(){},
		wash:function(){},
		ride:function(){},
		repair:function(){}
	}

	var californiaCruisers = new BicyleShop();
	var yourNewBike = californiaCruisers.sellBicyle('The Speedster');



//BicycleFactory是一个单体，用来把createBucycle方法封装在一个命名空间中。这个方法返回一个实现了Bicycle接口的对象



	var BicycleFactory = {
		createBicyle:function(model){
			var bicycle;

			switch(model){
				case 'The Speedster':
					bicycle = new Speedster();
					break;
				case 'The Lowrider':
					bicycle = new Lowrider();
				case 'The Comfort Cruiser':
				default:
					bicycle = new ComfortCruiser();
			}

			Interface.ensureImplements(bicycle,Bicyle);
			return bicycle;
		}
	}
	//这个BicycleFactory对象可以供各种类用来创建新的自行车实例。有关可供车型的所有信息都集中在一个地方管理，所以添加更多车型很容易。
	var BicyleShop = function(){};
	BicyleShop.prototype = {
		sellBicyle:function(model){
			var bicycle = BicycleFactory.createBicyle(model);

			bicycle.assemble();
			bicycle.wash();

			return bicycle;
		}
	}
	//这种模式把成员对象的创建工作转交给一个外部对象。
	//这个外部对象可以是一个简单的命名空间，也可以是一个类的实例。
	//如果负责创建实例的方法的逻辑不会发生改变，那么一般说来用单体或静态类方法创建这些成员实例是合乎情理的，但如果要提供几种不同品牌的自行车，那么更恰当的做法是把这个创建方法实现在一个类中，并从该类派生出一些子类。
	


	//真正的工厂模式与简单工厂模式的区别在于，它不是另外使用一个类或对象来创建自行车，而是使用一个子类。
	//按照正式定义，工厂是一个将其成员对象的实例化推迟到子类中进行的类。
</script>