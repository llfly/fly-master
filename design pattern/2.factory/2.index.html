<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
</html>
<script type="text/javascript">
//使用场景
//当对象或组建设置涉及高复杂性时
//当需要根据所在的不同环境轻松生成对象的不同实例时
//当处理很多共享相同属性的小型对象或组件时
//再编写只需要满足一个API契约（鸭子类型）的其他对象的实例对象时，对于解耦是很有用的。

//动态实现 创建一些用不同方式实现同一接口的对象
//节省设置开销
//对象需要进行复杂并且彼此相关的设置，使用工厂模式可以减少每种对象所需的代码量。
//用许多小型对象组成一个大对象
//可以用来创建封装了许多较小对象的对象。









//Abstract Factory（抽象工厂）
//用于封装一组具有共同目标的单个工厂
//能够将一组对象的实现细节从一般用法中分离出来
//使用场景：一个系统必须独立于它所创建的对象的生成方式，或它需要与多种对象类型一起工作。
function Car(options){
	this.doors = options.doors || 4;
	this.state = options.state || 'brand new';
	this.color = options.color || 'silver';
}
Car.prototype.drive = function(){};
Car.prototype.breakDown = function(){};


function Truck(options){
	this.state = options.state || 'used';
	this.wheelSize = options.wheelSize || 'large';
	this.color = options.color || 'blue';
}
Truck.prototype.drive = function(){};
Truck.prototype.breakDown = function(){};


var AbstractVehicleFactory = (function(){
	//存储车辆类型
	var types = {};
	return {
		getVehicle:function(type,customizations){
			var Vehicle = types[type];
			return (Vehicle)? new Vehicle(customizations) : null;
		},
		registerVehicle:function(type,Vehicle){
			var proto = Vehicle.prototype;
			//只注册实现车辆契约的类
			if(proto.drive && proto.breakDown){
				types[type] = Vehicle;
			}
			return AbstractVehicleFactory;
		}
	};
})();
//usge
AbstractVehicleFactory.registerVehicle('car',Car);
AbstractVehicleFactory.registerVehicle('truck',Truck);
//基于抽象车辆类型实例化一个新的car对象
var car = AbstractVehicleFactory.getVehicle('car',{
	color:'lime green',
	state:'like new'
});

var truck = AbstractVehicleFactory.getVehicle('truck',{
	wheelSize:'medium',
	color:'neon yellow'
});

</script>