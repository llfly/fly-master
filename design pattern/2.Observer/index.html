<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
</html>
<script type="text/javascript">
//观察者最主要的作用是解决类或对象之间的耦合，解耦两个相互依赖的对象，使其依赖于观察者的消息机制。
//对于任意一个订阅者对象来说，其他订阅者对象的改变不会影响到自身
//对于每一个订阅者来说，其自身既可以是消息的发出者也可以是消息的执行者，者依赖于调用观察者对象的三种方法（订阅消息，注销消息，发布消息）中的哪一种。

//将观察者放在闭包中，当页面加载就立即执行
var Observer =(function(){
	//防止消息队列暴露而被篡改故将消息容器作为静态私有变量保存；
	var __message = {};
	return {
		//注册信息接口
		regist:function(type,fn){
			//如果此消息不存在则应该创建一个该消息类型
			if(typeof __message[type] === 'undefined'){
				//将动作推入到该消息对应的动作执行队列中
				__message[type] = [fn];
			}//如果此消息存在
			else{
				//将动作方法推入该消息对应的动作执行序列中
				__message[type].push(fn);
			}
		},
		//发布信息接口
		fire:function(type,args){
			//如果该消息没有被注册，则返回
			if(!__message[type])
				return;
			//定义消息信息
			var events = {
				type:type,
				args:args || {}
			},
			i = 0,
			len = __message[type].length;
			//遍历消息动作
			for(;i<len;i++){
				//依次执行注册的消息对应的动作序列
				__message[type][i].call(this,events);
			}
		},
		//移除信息接口
		remove:function(type,fn){
			//如果消息动作队列存在
			if(__message[type] instanceof Array){
				//从最后一个消息动作遍历
				var i = __message[type].length - 1;
				for(;i>=0;i--){
					//如果存在该动作则在消息动作序列中移除相应动作
					__message[type][i] === fn && __message[type].splice(i,1);
				}
			}
		}
	}
})();

//test
Observer.regist('test',function(e){
	console.log(e.type,e.args.msg);
});

// Observer.regist('test',function(e){
// 	console.log(e.type,e.args.msg + '___');
// });

Observer.fire('test',{msg:'传递参数'});

</script>